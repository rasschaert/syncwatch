#!/usr/bin/env ruby
require 'json'
require 'English'

configfile = 'syncwatch.json'

# This script runs forever unless killed, so handle ^C nicely
trap('INT') do
  print "\n\e[33m• Syncwatch shutting down.\e[0m\n"
  exit
end

# Open and parse the JSON config file
def read_config(configfile)
  begin
    file = File.read(configfile)
    parsed_config = JSON.parse(file)
  rescue
    abort("ERROR: Error parsing configuration file #{configfile}. " \
      'Does it exist and is it valid JSON?')
  end
  parsed_config
end

# Configuration blocks allow for lists of remote hosts, those are
# split into seperate configuration blocks here
def split_multi_remotehost_config_blocks(config_block)
  split_config = []
  config_block['remotehost'].each do |single_remote_host|
    # Clone the block containing the multiple remote hosts
    config_block_for_single_remote_host = config_block.clone
    # And replace them with a single remote host
    config_block_for_single_remote_host['remotehost'] = single_remote_host
    split_config.push(config_block_for_single_remote_host)
  end
  # Return split config blocks that each have a single remote host
  split_config
end

# Do some processing on the config file
def process_config(parsed_config)
  final_config = []
  parsed_config.each do |config_block|
    # Skip any blocks that are explicitely not enabled
    next if config_block.key?('enabled') && !config_block['enabled']
    if config_block['remotehost'].instance_of? Array
      final_config += split_multi_remotehost_config_blocks(config_block)
    else
      final_config << config_block
    end
  end
  final_config
end

# Start a watch thread
def start_watch(sourcepath, remotepath, remotehost, rsync_options, watchid)
  loop do
    # fswatch options:
    #   -1: exit after one iteration
    #   -r: recurse
    #   -L: follow symlinks
    #   --event Updated/Removed/Created: only shows events that signify change
    fswatch_options = '-1 -rL --event Updated --event Removed --event Created'
    watch_cmd = "fswatch #{fswatch_options} \"#{sourcepath}\""
    # fswatch command stops the thread until it exits, when it detects a change
    `#{watch_cmd}`
    # if there's no remotehost, there's no need for an rsync or loop, so return
    return if remotehost.nil?
    sync_msg(sourcepath, remotepath, remotehost, watchid)
    sync(sourcepath, remotepath, remotehost, rsync_options)
  end
end

def sync(sourcepath, remotepath, remotehost, rsync_options)
  sleep_time = 0
  Thread.list.each_with_index do |thread, index|
    thread == Thread.current && sleep_time = index * 0.1
  end
  sync_cmd = "sleep #{sleep_time};rsync #{rsync_options} #{sourcepath} " \
    "#{remotehost}:#{remotepath} &>/dev/null"
  `#{sync_cmd}`
  abort("Rsync command `#{sync_cmd}` failed.") if $CHILD_STATUS.to_i != 0
end

def sync_msg(sourcepath, remotepath, remotehost, watchid = nil)
  prefix = "[#{watchid}] " unless watchid.nil?
  print "  \e[32m‣ #{prefix}Syncing \e[0m#{sourcepath} \e[32m→\e[0m" \
    " #{remotehost}:#{remotepath}\n"
end

def watch_msg(sourcepath, watchid)
  puts "  \e[34m‖ [#{watchid}] Watching\e[0m #{sourcepath}"
end

def exit_watches
  print "  \e[35m↻ [0] Configuration changed, reloading\e[0m\n"
  Thread.list.each do |thread|
    thread.exit if thread != Thread.main && thread != Thread.current
  end
end

def create_watch_threads(watch_threads, config)
  config.each_with_index do |watch, index|
    watch_msg(watch['sourcepath'], index + 1)
    watch_threads << Thread.new do
      start_watch(watch['sourcepath'], watch['remotepath'],
                  watch['remotehost'], watch['rsync_options'], index + 1)
    end
  end
  watch_threads
end

# An infinite loop lets this script reload when the configuration file changes
loop do
  config = process_config(read_config(configfile))
  # Create a thread for each initial sync
  initial_sync_threads = []
  puts "\e[33m• Performing initial syncs\e[0m"
  config.each_with_index do |watch, index|
    sync_msg(watch['sourcepath'], watch['remotepath'], watch['remotehost'],
             index + 1)
    initial_sync_threads << Thread.new do
      sync(watch['sourcepath'], watch['remotepath'], watch['remotehost'],
           watch['rsync_options'])
    end
  end
  # Start all initial sync threads and wait for them to end
  initial_sync_threads.each(&:join)
  # Watch threads
  watch_threads = []
  puts "\e[33m• Watching for changes\e[0m"
  # Create a thread for the configuration watch
  watch_msg(configfile, 0)
  watch_threads << Thread.new do
    start_watch(configfile, nil, nil, nil, 0)
    exit_watches
  end
  # Create a thread for each user defined watch
  watch_threads = create_watch_threads(watch_threads, config)

  # Start all watch threads and wait for them to end
  watch_threads.each(&:join)
end
